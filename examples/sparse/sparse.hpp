
// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace sparse_model_namespace {

template <typename T, typename S>
std::vector<T> resize_to_match__(std::vector<T> &dst,
                                 const std::vector<S> &src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, -1>
resize_to_match__(Eigen::Matrix<T, -1, -1> &dst,
                  const Eigen::Matrix<T, -1, -1> &src) {
  dst.resize(src.rows(), src.cols());
  return dst;
}

template <typename T>
Eigen::Matrix<T, 1, -1> resize_to_match__(Eigen::Matrix<T, 1, -1> &dst,
                                          const Eigen::Matrix<T, 1, -1> &src) {
  dst.resize(src.size());
  return dst;
}

template <typename T>
Eigen::Matrix<T, -1, 1> resize_to_match__(Eigen::Matrix<T, -1, 1> &dst,
                                          const Eigen::Matrix<T, -1, 1> &src) {
  dst.resize(src.size());
  return dst;
}
std::vector<double> to_doubles__(std::initializer_list<double> x) { return x; }

std::vector<stan::math::var>
to_vars__(std::initializer_list<stan::math::var> x) {
  return x;
}

inline void validate_positive_index(const char *var_name, const char *expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

inline void validate_unit_vector_index(const char *var_name, const char *expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}

using stan::io::dump;
using stan::math::lgamma;
using stan::model::cons_list;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::index_uni;
using stan::model::model_base_crtp;
using stan::model::nil_index_list;
using stan::model::rvalue;
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using namespace stan::math;

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {
    " (found before start of program)",
    " (in './examples/sparse/sparse.stan', line 24, column 2 to column 43)",
    " (in './examples/sparse/sparse.stan', line 28, column 2 to column 40)",
    " (in './examples/sparse/sparse.stan', line 33, column 2 to column 34)",
    " (in './examples/sparse/sparse.stan', line 2, column 2 to column 8)",
    " (in './examples/sparse/sparse.stan', line 3, column 2 to column 8)",
    " (in './examples/sparse/sparse.stan', line 4, column 2 to column 14)",
    " (in './examples/sparse/sparse.stan', line 5, column 2 to column 23)",
    " (in './examples/sparse/sparse.stan', line 6, column 2 to column 23)",
    " (in './examples/sparse/sparse.stan', line 7, column 2 to column 42)",
    " (in './examples/sparse/sparse.stan', line 9, column 2 to column 28)",
    " (in './examples/sparse/sparse.stan', line 13, column 2 to column 44)",
    " (in './examples/sparse/sparse.stan', line 18, column 2 to column 33)"};

class sparse_model : public model_base_crtp<sparse_model> {

private:
  int pos__;
  int N;
  int M;
  int nz_vals;
  std::vector<int> nz_rows;
  std::vector<int> nz_cols;
  Eigen::SparseMatrix<double> x;
  Eigen::SparseMatrix<double> bad_x;
  Eigen::SparseMatrix<double> xx;

public:
  ~sparse_model() {}

  std::string model_name() const { return "sparse_model"; }

  sparse_model(stan::io::var_context &context__, unsigned int random_seed__ = 0,
               std::ostream *pstream__ = nullptr)
      : model_base_crtp(0) {
    typedef double local_scalar_t__;
    boost::ecuyer1988 base_rng__ =
        stan::services::util::create_rng(random_seed__, 0);
    (void)base_rng__; // suppress unused var warning
    static const char *function__ = "sparse_model_namespace::sparse_model";
    (void)function__; // suppress unused var warning

    try {

      pos__ = 1;
      context__.validate_dims("data initialization", "N", "int",
                              context__.to_vec());

      current_statement__ = 4;
      N = context__.vals_i("N")[(1 - 1)];
      context__.validate_dims("data initialization", "M", "int",
                              context__.to_vec());

      current_statement__ = 5;
      M = context__.vals_i("M")[(1 - 1)];
      context__.validate_dims("data initialization", "nz_vals", "int",
                              context__.to_vec());

      current_statement__ = 6;
      nz_vals = context__.vals_i("nz_vals")[(1 - 1)];
      current_statement__ = 7;
      validate_non_negative_index("nz_rows", "nz_vals", nz_vals);
      context__.validate_dims("data initialization", "nz_rows", "int",
                              context__.to_vec(nz_vals));
      nz_rows = std::vector<int>(nz_vals, 0);

      current_statement__ = 7;
      assign(nz_rows, nil_index_list(), context__.vals_i("nz_rows"),
             "assigning variable nz_rows");
      current_statement__ = 8;
      validate_non_negative_index("nz_cols", "nz_vals", nz_vals);
      context__.validate_dims("data initialization", "nz_cols", "int",
                              context__.to_vec(nz_vals));
      nz_cols = std::vector<int>(nz_vals, 0);

      current_statement__ = 8;
      assign(nz_cols, nil_index_list(), context__.vals_i("nz_cols"),
             "assigning variable nz_cols");
      current_statement__ = 9;
      validate_non_negative_index("x", "N", N);
      current_statement__ = 9;
      validate_non_negative_index("x", "M", M);
      context__.validate_dims("data initialization", "x", "double",
                              context__.to_vec(nz_rows, nz_cols, N, M));
      x = Eigen::SparseMatrix<double>(N, M);

      {
        std::vector<local_scalar_t__> x_flat__;
        current_statement__ = 9;
        assign(x_flat__, nil_index_list(), context__.vals_r("x"),
               "assigning variable x_flat__");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (size_t sym1__ = 1; sym1__ <= stan::math::size(nz_rows); ++sym1__) {
          current_statement__ = 9;
          assign(x,
                 cons_list(index_uni(nz_cols[(sym1__ - 1)]),
                           cons_list(index_uni(nz_rows[(sym1__ - 1)]),
                                     nil_index_list())),
                 x_flat__[(pos__ - 1)], "assigning variable x");
          current_statement__ = 9;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 10;
      validate_non_negative_index("bad_x", "N", N);
      current_statement__ = 10;
      validate_non_negative_index("bad_x", "M", M);
      context__.validate_dims("data initialization", "bad_x", "double",
                              context__.to_vec(N, M));
      bad_x = Eigen::SparseMatrix<double>(N, M);

      {
        std::vector<local_scalar_t__> bad_x_flat__;
        current_statement__ = 10;
        assign(bad_x_flat__, nil_index_list(), context__.vals_r("bad_x"),
               "assigning variable bad_x_flat__");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (size_t sym1__ = 1; sym1__ <= N; ++sym1__) {
          current_statement__ = 10;
          for (size_t sym2__ = 1; sym2__ <= M; ++sym2__) {
            current_statement__ = 10;
            assign(bad_x,
                   cons_list(index_uni(sym2__),
                             cons_list(index_uni(sym1__), nil_index_list())),
                   bad_x_flat__[(pos__ - 1)], "assigning variable bad_x");
            current_statement__ = 10;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 11;
      validate_non_negative_index("xx", "N", N);
      current_statement__ = 11;
      validate_non_negative_index("xx", "M", M);
      xx = Eigen::SparseMatrix<double>(N, M);

      current_statement__ = 11;
      for (size_t sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 11;
        for (size_t sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 11;
          assign(xx,
                 cons_list(index_uni(sym1__),
                           cons_list(index_uni(sym2__), nil_index_list())),
                 std::numeric_limits<double>::quiet_NaN(),
                 "assigning variable xx");
        }
      }
      current_statement__ = 11;
      assign(xx, nil_index_list(), multiply(x, transpose(x)),
             "assigning variable xx");
      current_statement__ = 12;
      assign(
          xx,
          cons_list(index_min_max(1, 10),
                    cons_list(index_min_max(1, 10), nil_index_list())),
          rvalue(x,
                 cons_list(index_min_max(1, 10),
                           cons_list(index_min_max(1, 10), nil_index_list())),
                 "x"),
          "assigning variable xx");
    } catch (const std::exception &e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
    num_params_r__ = 0U;

    try {
      current_statement__ = 1;
      validate_non_negative_index("VV", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("VV", "M", M);
      num_params_r__ += nz_rows * nz_cols * N * M;
    } catch (const std::exception &e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
  }
  template <bool propto__, bool jacobian__, typename T__>
  T__ log_prob(std::vector<T__> &params_r__, std::vector<int> &params_i__,
               std::ostream *pstream__ = 0) const {
    typedef T__ local_scalar_t__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char *function__ = "sparse_model_namespace::log_prob";
    (void)function__; // suppress unused var warning

    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);

    try {
      current_statement__ = 1;
      validate_non_negative_index("VV", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("VV", "M", M);
      Eigen::SparseMatrix<local_scalar_t__> VV;
      VV = Eigen::SparseMatrix<local_scalar_t__>(N, M);

      current_statement__ = 1;
      VV = in__.sparse_matrix(nz_rows, nz_cols, N, M);
      current_statement__ = 2;
      validate_non_negative_index("ZZ", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("ZZ", "M", M);
      Eigen::SparseMatrix<local_scalar_t__> ZZ;
      ZZ = Eigen::SparseMatrix<local_scalar_t__>(N, M);

      current_statement__ = 2;
      for (size_t sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        for (size_t sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 2;
          assign(ZZ,
                 cons_list(index_uni(sym1__),
                           cons_list(index_uni(sym2__), nil_index_list())),
                 std::numeric_limits<double>::quiet_NaN(),
                 "assigning variable ZZ");
        }
      }
      current_statement__ = 2;
      assign(ZZ, nil_index_list(), multiply(VV, nz_vals),
             "assigning variable ZZ");
      current_statement__ = 3;
      assign(
          ZZ,
          cons_list(index_min_max(1, 10),
                    cons_list(index_min_max(1, 10), nil_index_list())),
          rvalue(VV,
                 cons_list(index_min_max(1, 10),
                           cons_list(index_min_max(1, 10), nil_index_list())),
                 "VV"),
          "assigning variable ZZ");
    } catch (const std::exception &e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  } // log_prob()

  template <typename RNG>
  void write_array(RNG &base_rng__, std::vector<double> &params_r__,
                   std::vector<int> &params_i__, std::vector<double> &vars__,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream *pstream__ = 0) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char *function__ = "sparse_model_namespace::write_array";
    (void)function__; // suppress unused var warning

    (void)function__; // suppress unused var warning

    double lp__ = 0.0;
    (void)lp__; // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;

    try {
      current_statement__ = 1;
      validate_non_negative_index("VV", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("VV", "M", M);
      Eigen::SparseMatrix<double> VV;
      VV = Eigen::SparseMatrix<double>(N, M);

      current_statement__ = 1;
      VV = in__.sparse_matrix(nz_rows, nz_cols, N, M);
      current_statement__ = 2;
      validate_non_negative_index("ZZ", "N", N);
      current_statement__ = 2;
      validate_non_negative_index("ZZ", "M", M);
      Eigen::SparseMatrix<double> ZZ;
      ZZ = Eigen::SparseMatrix<double>(N, M);

      current_statement__ = 2;
      for (size_t sym1__ = 1; sym1__ <= N; ++sym1__) {
        current_statement__ = 2;
        for (size_t sym2__ = 1; sym2__ <= M; ++sym2__) {
          current_statement__ = 2;
          assign(ZZ,
                 cons_list(index_uni(sym1__),
                           cons_list(index_uni(sym2__), nil_index_list())),
                 std::numeric_limits<double>::quiet_NaN(),
                 "assigning variable ZZ");
        }
      }
      for (size_t sym1__ = 1; sym1__ <= stan::math::size(nz_rows); ++sym1__) {
        vars__.push_back(
            rvalue(VV,
                   cons_list(index_uni(nz_cols[(sym1__ - 1)]),
                             cons_list(index_uni(nz_rows[(sym1__ - 1)]),
                                       nil_index_list())),
                   "VV"));
      }
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
                            primitive_value(emit_generated_quantities__)))) {
        return;
      }
      current_statement__ = 2;
      assign(ZZ, nil_index_list(), multiply(VV, nz_vals),
             "assigning variable ZZ");
      current_statement__ = 3;
      assign(
          ZZ,
          cons_list(index_min_max(1, 10),
                    cons_list(index_min_max(1, 10), nil_index_list())),
          rvalue(VV,
                 cons_list(index_min_max(1, 10),
                           cons_list(index_min_max(1, 10), nil_index_list())),
                 "VV"),
          "assigning variable ZZ");
      for (size_t sym1__ = 1; sym1__ <= N; ++sym1__) {
        for (size_t sym2__ = 1; sym2__ <= M; ++sym2__) {
          vars__.push_back(
              rvalue(ZZ,
                     cons_list(index_uni(sym2__),
                               cons_list(index_uni(sym1__), nil_index_list())),
                     "ZZ"));
        }
      }
      if (logical_negation(emit_generated_quantities__)) {
        return;
      }
    } catch (const std::exception &e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
  } // write_array()

  void transform_inits(const stan::io::var_context &context__,
                       std::vector<int> &params_i__,
                       std::vector<double> &vars__,
                       std::ostream *pstream__) const {
    typedef double local_scalar_t__;
    vars__.resize(0);
    vars__.reserve(num_params_r__);

    try {
      int pos__;

      pos__ = 1;
      current_statement__ = 1;
      validate_non_negative_index("VV", "N", N);
      current_statement__ = 1;
      validate_non_negative_index("VV", "M", M);
      Eigen::SparseMatrix<double> VV;
      VV = Eigen::SparseMatrix<double>(N, M);

      {
        std::vector<local_scalar_t__> VV_flat__;
        current_statement__ = 1;
        assign(VV_flat__, nil_index_list(), context__.vals_r("VV"),
               "assigning variable VV_flat__");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (size_t sym1__ = 1; sym1__ <= stan::math::size(nz_rows); ++sym1__) {
          current_statement__ = 1;
          assign(VV,
                 cons_list(index_uni(nz_cols[(sym1__ - 1)]),
                           cons_list(index_uni(nz_rows[(sym1__ - 1)]),
                                     nil_index_list())),
                 VV_flat__[(pos__ - 1)], "assigning variable VV");
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      for (size_t sym1__ = 1; sym1__ <= stan::math::size(nz_rows); ++sym1__) {
        vars__.push_back(
            rvalue(VV,
                   cons_list(index_uni(nz_cols[(sym1__ - 1)]),
                             cons_list(index_uni(nz_rows[(sym1__ - 1)]),
                                       nil_index_list())),
                   "VV"));
      }
    } catch (const std::exception &e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
  } // transform_inits()

  void get_param_names(std::vector<std::string> &names__) const {

    names__.resize(0);
    names__.push_back("VV");
    names__.push_back("ZZ");
  } // get_param_names()

  void get_dims(std::vector<std::vector<size_t>> &dimss__) const {
    dimss__.resize(0);
    std::vector<size_t> dims__;
    dims__.push_back(nz_rows);

    dims__.push_back(nz_cols);

    dims__.push_back(N);

    dims__.push_back(M);
    dimss__.push_back(dims__);
    dims__.resize(0);
    dims__.push_back(N);

    dims__.push_back(M);
    dimss__.push_back(dims__);
    dims__.resize(0);

  } // get_dims()

  void constrained_param_names(std::vector<std::string> &param_names__,
                               bool emit_transformed_parameters__ = true,
                               bool emit_generated_quantities__ = true) const {

    for (size_t sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (size_t sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (size_t sym3__ = 1; sym3__ <= nz_cols; ++sym3__) {
              {
                for (size_t sym4__ = 1; sym4__ <= nz_rows; ++sym4__) {
                  {
                    param_names__.push_back(
                        std::string() + "VV" + '.' + std::to_string(sym4__) +
                        '.' + std::to_string(sym3__) + '.' +
                        std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }
                }
              }
            }
          }
        }
      }
    }
    if (emit_transformed_parameters__) {
      for (size_t sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          for (size_t sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "ZZ" + '.' +
                                      std::to_string(sym2__) + '.' +
                                      std::to_string(sym1__));
            }
          }
        }
      }
    }

    if (emit_generated_quantities__) {
    }

  } // constrained_param_names()

  void
  unconstrained_param_names(std::vector<std::string> &param_names__,
                            bool emit_transformed_parameters__ = true,
                            bool emit_generated_quantities__ = true) const {

    for (size_t sym1__ = 1; sym1__ <= M; ++sym1__) {
      {
        for (size_t sym2__ = 1; sym2__ <= N; ++sym2__) {
          {
            for (size_t sym3__ = 1; sym3__ <= nz_cols; ++sym3__) {
              {
                for (size_t sym4__ = 1; sym4__ <= nz_rows; ++sym4__) {
                  {
                    param_names__.push_back(
                        std::string() + "VV" + '.' + std::to_string(sym4__) +
                        '.' + std::to_string(sym3__) + '.' +
                        std::to_string(sym2__) + '.' + std::to_string(sym1__));
                  }
                }
              }
            }
          }
        }
      }
    }
    if (emit_transformed_parameters__) {
      for (size_t sym1__ = 1; sym1__ <= M; ++sym1__) {
        {
          for (size_t sym2__ = 1; sym2__ <= N; ++sym2__) {
            {
              param_names__.push_back(std::string() + "ZZ" + '.' +
                                      std::to_string(sym2__) + '.' +
                                      std::to_string(sym1__));
            }
          }
        }
      }
    }

    if (emit_generated_quantities__) {
    }

  } // unconstrained_param_names()

  std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"VV\",\"type\":{\"name\":\"sparse_matrix\",\"nonzero "
           "rows\":"
        << nz_rows << ",\"nonzero cols\":" << nz_cols << ",\"rows\":" << N
        << ",\"cols\":" << M
        << "},\"block\":\"parameters\"},{\"name\":\"ZZ\",\"type\":{\"name\":"
           "\"sparse_matrix\",\"rows\":"
        << N << ",\"cols\":" << M << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
  } // get_constrained_sizedtypes()

  std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"VV\",\"type\":{\"name\":\"sparse_matrix\",\"nonzero "
           "rows\":"
        << nz_rows << ",\"nonzero cols\":" << nz_cols << ",\"rows\":" << N
        << ",\"cols\":" << M
        << "},\"block\":\"parameters\"},{\"name\":\"ZZ\",\"type\":{\"name\":"
           "\"sparse_matrix\",\"rows\":"
        << N << ",\"cols\":" << M << "},\"block\":\"transformed_parameters\"}]";
    return s__.str();
  } // get_unconstrained_sizedtypes()

  // Begin method overload boilerplate
  template <typename RNG>
  void write_array(RNG &base_rng__,
                   Eigen::Matrix<double, Eigen::Dynamic, 1> &params_r,
                   Eigen::Matrix<double, Eigen::Dynamic, 1> &vars,
                   bool emit_transformed_parameters__ = true,
                   bool emit_generated_quantities__ = true,
                   std::ostream *pstream = 0) const {
    std::vector<double> params_r_vec(params_r.size());
    for (int i = 0; i < params_r.size(); ++i)
      params_r_vec[i] = params_r(i);
    std::vector<double> vars_vec;
    std::vector<int> params_i_vec;
    write_array(base_rng__, params_r_vec, params_i_vec, vars_vec,
                emit_transformed_parameters__, emit_generated_quantities__,
                pstream);
    vars.resize(vars_vec.size());
    for (int i = 0; i < vars.size(); ++i)
      vars(i) = vars_vec[i];
  }

  template <bool propto__, bool jacobian__, typename T_>
  T_ log_prob(Eigen::Matrix<T_, Eigen::Dynamic, 1> &params_r,
              std::ostream *pstream = 0) const {
    std::vector<T_> vec_params_r;
    vec_params_r.reserve(params_r.size());
    for (int i = 0; i < params_r.size(); ++i)
      vec_params_r.push_back(params_r(i));
    std::vector<int> vec_params_i;
    return log_prob<propto__, jacobian__, T_>(vec_params_r, vec_params_i,
                                              pstream);
  }

  void transform_inits(const stan::io::var_context &context,
                       Eigen::Matrix<double, Eigen::Dynamic, 1> &params_r,
                       std::ostream *pstream__) const {
    std::vector<double> params_r_vec;
    std::vector<int> params_i_vec;
    transform_inits(context, params_i_vec, params_r_vec, pstream__);
    params_r.resize(params_r_vec.size());
    for (int i = 0; i < params_r.size(); ++i)
      params_r(i) = params_r_vec[i];
  }
};
} // namespace sparse_model_namespace
typedef sparse_model_namespace::sparse_model stan_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base &new_model(stan::io::var_context &data_context,
                                   unsigned int seed,
                                   std::ostream *msg_stream) {
  stan_model *m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

#endif
